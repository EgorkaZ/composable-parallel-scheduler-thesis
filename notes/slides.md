# Заметки к предзащите

## План
- Решаемая проблема
    - Предметная область
    - Актуальность
    - Цели и задачи исследования
- Постановка задачи
- Решение задачи
- Апробация (бенчмарки)


### Проблема
#### Предметная область
TODO: взять описание к теме
Предположим, в программе нужно что-то распараллелить и выполнить какой-то алгоритм в N потоков - возьмём простейший parallel_for.
Как это можно сделать? Можно запустить N потоков, раздать каждому 1/N от диапазона и дождаться завершения всех. Примерно так работает OpenMP static.
Другой же способ - побить диапазон на какие-то задачи (вплоть до размера 1) и вызвать Schedule(...) у какого-то обобщенного исполнителя задач, а затем дождаться их завершения. Примерно так работает OneTBB.

Слайд: тут небольшой пример кода openmp/tbb, мб псевдокода

Очевидно, что раз существуют популярные реализации двух разных подходов, то они обе имеют свои преимущества - и это правда так.
Большинство планировщиков задач внутри обычно они выглядят как N очередей и work-stealing поверх них - если у потока кончились задачи в очереди, он идет по соседям и ищет задачи у них. Такой вариант достаточно хорошо подходит для произвольного паттерна нагрузки, позволяя справляться с несбалансированными и переваривать параллелизм любых уровней.

Слайд: может какую-то картинку с очередями и work-stealing'ом

Преимущество статического распределения работы же в том, что само распределение происходит быстрее, а кроме того мы избавляемся от оверхеда, который вносит балансировка задач - запущенные потоки просто получают как можно быстрее свои блоки и начинают его молотить без дополнительного оверхеда на перекладывание задач из очереди. Очевидна проблема - это прекрасно работает на равномерном распределении работы, но сильно. Вдобавок любой вложенный параллелизм перестает работать - как только потоков у нас больше, чем ядер, они начинают голодать, начинаются переключения между ними (context switch) и становится резко хуже.

TODO: тут нужно про premature stealing что-то

#### Актуальность
Актуальность понятна:  можем распределять блоками статически и хорошо работать в равномерной нагрузке, а можем использовать задачки и work-stealing и хорошо справляться с неравномерным распределением работы. Но как быть, если хочется и то и другое и в рантайме объем работы не известен? Нужно искать компромиссы между этими подходами.
#### Цели и задачи исследования
- Измерять разницу в сущестующих реализациях на разных паттернах нагрузки
- Исследовать, в чем основные оверхеды (TODO: как по-русски оверхед) в распределении работы и как их можно избежать
- Реализовать возможные идеи и сравнить с существующими фреймворками
#### Постановка задачи
TODO
#### Решение задачи
- Рассказ про распределение задачек
- Рассказ про идею timespan и как это решает проблему излишнего load balancing
#### Апробация
Тут коротко про типы бенчмарков (можно табличку?)
И результаты бенчмарков, подсветив где лучше/где хуже
